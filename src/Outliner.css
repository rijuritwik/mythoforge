import React, { useState } from 'react';
import './Outliner.css';

const initialData = {
  name: 'Book 1',
  children: [
    {
      name: 'Section 1',
      children: [
        {
          name: 'Chapter 1',
          children: [
            { name: 'Scene 1', content: '', goal: 500 },
            { name: 'Scene 2', content: '', goal: 500 }
          ]
        }
      ]
    }
  ]
};

function TreeNode({ node, onSelect }) {
  const [expanded, setExpanded] = useState(true);

  const isScene = !node.children;

  return (
    <div className="tree-node">
      <div
        className={isScene ? 'scene-node' : 'folder-node'}
        onClick={() => {
          if (isScene) onSelect(node);
          else setExpanded(!expanded);
        }}
      >
        {isScene ? 'ğŸ“' : expanded ? 'ğŸ“‚' : 'ğŸ“'} {node.name}
      </div>
      {expanded &&
        node.children?.map((child, idx) => (
          <TreeNode key={idx} node={child} onSelect={onSelect} />
        ))}
    </div>
  );
}

export default function OutlinerApp() {
  const [selectedScene, setSelectedScene] = useState(null);
  const [sceneHistory, setSceneHistory] = useState([]);
  const [tagIndex, setTagIndex] = useState({});
  const [logicErrors, setLogicErrors] = useState([]);
  const [vaultInput, setVaultInput] = useState('');
  const [vault, setVault] = useState([]);

  const updateScene = (text) => {
    const updatedScene = { ...selectedScene, content: text };
    setSelectedScene(updatedScene);
    handleTags(updatedScene.name, text);
    validateLogic(text);
    saveVersion(updatedScene);
  };

  const handleTags = (sceneName, text) => {
    const foundTags = text.match(/@(\w+)/g) || [];
    const newIndex = { ...tagIndex };
    foundTags.forEach(tag => {
      const key = tag.slice(1);
      if (!newIndex[key]) newIndex[key] = [];
      if (!newIndex[key].includes(sceneName)) {
        newIndex[key].push(sceneName);
      }
    });
    setTagIndex(newIndex);
  };

  const validateLogic = (text) => {
    const errors = [];
    if (text.includes('@@')) errors.push('âš ï¸ Double @ symbol found.');
    if (text.includes('[[') && !text.includes(']]'))
      errors.push('âš ï¸ Unclosed [[ link found.');
    setLogicErrors(errors);
  };

  const saveVersion = (scene) => {
    const timestamp = new Date().toLocaleString();
    setSceneHistory([{ ...scene, timestamp }, ...sceneHistory]);
  };

  const restoreVersion = (index) => {
    const version = sceneHistory[index];
    setSelectedScene({ ...version });
  };

  const saveToVault = () => {
    if (vaultInput.trim()) {
      setVault([vaultInput.trim(), ...vault]);
      setVaultInput('');
    }
  };

  return (
    <div className="container">
      <div className="left-panel">
        <h2>ğŸ“˜ MythoForge</h2>
        <TreeNode node={initialData} onSelect={setSelectedScene} />
      </div>

      <div className="middle-panel">
        {selectedScene ? (
          <>
            <h3>{selectedScene.name}</h3>
            <textarea
              rows={15}
              value={selectedScene.content}
              onChange={(e) => updateScene(e.target.value)}
              placeholder="Write your scene..."
            />
            <div className="word-count">
              {selectedScene.content.length}/{selectedScene.goal}
              <progress
                value={selectedScene.content.length}
                max={selectedScene.goal}
              />
            </div>
          </>
        ) : (
          <p>Select a scene to start writing.</p>
        )}
      </div>

      <div className="right-panel">
        <h3>ğŸ“– Entity Index Viewer</h3>
        <ul>
          {Object.keys(tagIndex).map(tag => (
            <li key={tag}>
              <strong>@{tag}</strong>: {tagIndex[tag].join(', ')}
            </li>
          ))}
        </ul>

        <h3>ğŸ•° Scene Version Timeline</h3>
        <ul>
          {sceneHistory.map((entry, i) => (
            <li key={i}>
              <button onClick={() => restoreVersion(i)}>{entry.timestamp}</button>
            </li>
          ))}
        </ul>

        <h3>ğŸ” Logic Validator</h3>
        <ul>
          {logicErrors.map((err, i) => (
            <li key={i} style={{ color: 'tomato' }}>{err}</li>
          ))}
        </ul>

        <h3>ğŸ“‚ Vault of Echoes</h3>
        <textarea
          value={vaultInput}
          onChange={(e) => setVaultInput(e.target.value)}
          placeholder="Ideas, quotes, unused dialogues..."
          rows={3}
        />
        <button onClick={saveToVault}>Save to Vault</button>
        <ul>
          {vault.map((entry, i) => (
            <li key={i}>{entry}</li>
          ))}
        </ul>
      </div>
    </div>
  );
}
